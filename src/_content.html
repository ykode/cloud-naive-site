<section>
  <h1>
    What?
  </h1>
  <p>
    <strong>Cloud Naïve</strong> is tongue-in-cheek word in contrast to the term 
    <strong class="highlight-neg">Cloud Native</strong>. 
    Where <strong class="highlight-neg">Cloud Native</strong> talks about tools and practises building big software. We're seeking ways to use less computing 
    resources by reducing
    <em>footprint</em>, <em>computing</em>, and <em>storage</em> consumption. We're also advocating awareness of impact of
    complex architecture and slow software to <em>operation</em>, <em>developer productivity</em>, <em>computing power</em> and
    <em>business' bottom line</em> <i data-feather="external-link"></i>.
  </p>
  <h1>Why?</h1>
  <h2>We build less efficient software</h2>
  <p>Todays software becomes big and bloated. We've made our machine faster and consume less power.
    Hardware becomes more efficient but the software is not. <em>It is common to use hardware efficiency and power
    as an excuse for developer productivity</em>. So, a little inefficiency here and there are okay because
    hardware becomes faster. Writing hello world nowadays consumes tens or megabytes of runtime and dependencies and
    CPU cycle thousands time more compared to software written a little more than 2 decades ago.
  </p>
  <h2>Modern software development encourages inefficiency</h2>
  <p>
    Modern software architecture doesn't help too. People are making microservices spinning multiple nodes of virtual
    machines just because it's all the cool kids have. Even if the software can run on single node with embedded
    database running on an SSD. <em>Microservices architecture has its own purpose</em>. Before you dive in, ask
    yourself whether you want to deal with its <em>complexity and cost</em>.
  </p>
  <h2>Inefficient software is bad for environment</h2>
  <p>
    Inefficient software consumes more power compared to efficient software with the same result. That power came
    from power plants which increase the <em>carbon dioxide footprint</em>. If we consume less storage, less raw material
    to manufacture the storage media.
  </p>
  <h1>How?</h1>
  <h2>Create the simplest stack possible.</h2>
  <p>
    Being <strong>Cloud Naïve</strong> is about simplicity. <em>Most startups fail</em>, and businesses often do not scale to millions of users. 
    So why make a complicated with so many moving parts if you can create a simple, 
    <a href="/tta.html">three-tier architecture</a> with embedded database. There's no
    need to build a full-fledged cluster of container orchestration system if you're just getting started.
    <em>Scaling starts with well built software.</em> If your software was built badly, scaling in any direction 
    won't help.
  </p>
  <h2>
    Reduce network calls and distributed state.
  </h2>
  <p>
    Network calls come with a cost. When many services communicate within a network, a lot of things need to 
    be put in place to make the services <em>robust</em>, <em>reliable</em>, and <em>available</em>. 
    <a href="https://en.wikipedia.org/wiki/Fallacies_of_distributed_computing" target="_blank">
      Fallacies of distributed computing
    </a> is real thing. Network also a lot slower than plain <span class="font-mono">fopen()</span> operation.
    Not to mention the piling up complexities of <em>congestion</em>, <em>retries</em>, <em>load balancing</em>, 
    <em>service discovery</em>, and any <em>inherent networking complexities</em> inherent to microservices.
  </p>
  <h2>
    Simplify maintenance and pipeline.
  </h2>
  <p>
    If you're small software engineering shop, maybe you're deploying manually, maybe you're using a simple tool such
    as shell script. Having simpler software simplify the deployment and monitoring of the software. <em>Instead of
    spending your time and money for infrastructure, use them for growing your business</em>. It's fine to use a
    little shell script with <a href="https://en.wikipedia.org/wiki/Rsync">Rsync</a> to deploy your software.
  </p>
  <h2>
    Use better, faster, more efficient tools.
  </h2>
  <p>
    You don't need to <em>pull the whole internet</em> to build and run your software. Avoid programming languages,
    platforms, or framework with huge footprints, computing, and memory consumption. <em>In general, scripting languages
    are slower than compiled ones</em>. Amongst compiled languages, bytecode, JITed languages are slower than native binary
    executable. Slower languages consume more computing resources. 
  </p>
</section>
